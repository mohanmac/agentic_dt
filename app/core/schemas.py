"""
Pydantic schemas for type-safe data flow between agents and components.
"""
from pydantic import BaseModel, Field, validator
from typing import Optional, Dict, Any, List, Literal
from datetime import datetime
from enum import Enum


class MarketRegime(str, Enum):
    """Market regime classification."""
    TRENDING_UP = "trending_up"
    TRENDING_DOWN = "trending_down"
    RANGING = "ranging"
    VOLATILE = "volatile"
    WHIPSAW = "whipsaw"


class TradeSide(str, Enum):
    """Trade direction."""
    BUY = "buy"
    SELL = "sell"


class OrderType(str, Enum):
    """Order type."""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderStatus(str, Enum):
    """Order execution status."""
    PENDING = "pending"
    FILLED = "filled"
    PARTIAL = "partial"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class StrategyType(str, Enum):
    """Available trading strategies."""
    MOMENTUM_BREAKOUT = "momentum_breakout"
    MEAN_REVERSION = "mean_reversion"
    VWAP_CROSSOVER = "vwap_crossover"
    RSI_OVERSOLD = "rsi_oversold"
    MACD_CROSSOVER = "macd_crossover"
    BOLLINGER_SQUEEZE = "bollinger_squeeze"
    GAP_AND_GO = "gap_and_go"
    VOLATILITY_EXPANSION = "volatility_expansion"
    INSTITUTIONAL_FLOW = "institutional_flow"
    STOP_HUNT_PROTECTION = "stop_hunt_protection"
    NO_TRADE = "no_trade"


class MarketSnapshot(BaseModel):
    """Market state snapshot for strategy evaluation."""
    timestamp: datetime = Field(default_factory=datetime.now)
    symbol: str
    ltp: float = Field(..., description="Last traded price")
    open: float
    high: float
    low: float
    close: float
    volume: int
    
    # Technical indicators
    vwap: float = Field(..., description="Volume-weighted average price")
    sma_20: Optional[float] = None
    sma_50: Optional[float] = None
    bb_upper: Optional[float] = None
    bb_middle: Optional[float] = None
    bb_lower: Optional[float] = None
    bb_width: Optional[float] = None
    atr: Optional[float] = None
    
    # Market regime
    regime: MarketRegime
    trend_direction: str = Field(..., description="up/down/neutral")
    volatility_percentile: float = Field(..., ge=0, le=100)
    liquidity_score: float = Field(..., ge=0, le=1, description="0=illiquid, 1=highly liquid")
    
    # Additional metrics
    opening_range_high: Optional[float] = None
    opening_range_low: Optional[float] = None
    avg_volume_20d: Optional[int] = None
    
    class Config:
        json_schema_extra = {
            "example": {
                "symbol": "RELIANCE",
                "ltp": 2450.50,
                "vwap": 2448.75,
                "regime": "trending_up",
                "volatility_percentile": 65.5
            }
        }


class TradeIntent(BaseModel):
    """Trade intent generated by StrategyBrainAgent."""
    timestamp: datetime = Field(default_factory=datetime.now)
    strategy_id: StrategyType
    symbol: str
    side: TradeSide
    
    # Entry details
    entry_type: OrderType
    entry_price: Optional[float] = Field(None, description="None for market orders")
    quantity: int = Field(..., gt=0)
    
    # Risk management (MANDATORY)
    stop_loss_price: float = Field(..., description="Mandatory stop-loss price")
    target_price: Optional[float] = Field(None, description="Take-profit target")
    
    # Strategy reasoning
    confidence_score: float = Field(..., ge=0, le=1, description="Strategy confidence 0-1")
    rationale: str = Field(..., description="LLM-generated explanation")
    
    # Risk metrics
    expected_risk_rupees: float = Field(..., description="Expected loss if SL hit")
    invalidation_conditions: List[str] = Field(default_factory=list)
    
    # Metadata
    market_snapshot_id: Optional[int] = None
    
    @validator("stop_loss_price")
    def validate_stop_loss(cls, v, values):
        """Ensure stop-loss is on correct side of entry."""
        if "side" in values and "entry_price" in values and values["entry_price"]:
            if values["side"] == TradeSide.BUY and v >= values["entry_price"]:
                raise ValueError("Stop-loss for BUY must be below entry price")
            if values["side"] == TradeSide.SELL and v <= values["entry_price"]:
                raise ValueError("Stop-loss for SELL must be above entry price")
        return v
    
    class Config:
        json_schema_extra = {
            "example": {
                "strategy_id": "momentum_breakout",
                "symbol": "RELIANCE",
                "side": "buy",
                "entry_type": "market",
                "quantity": 10,
                "stop_loss_price": 2400.00,
                "target_price": 2500.00,
                "confidence_score": 0.78,
                "rationale": "Strong breakout above VWAP with volume confirmation",
                "expected_risk_rupees": 150.00
            }
        }


class RiskApproval(BaseModel):
    """Risk approval decision from RiskPolicyAgent."""
    timestamp: datetime = Field(default_factory=datetime.now)
    intent_id: Optional[int] = None
    
    # Decision
    approved: bool
    adjusted_quantity: Optional[int] = Field(None, description="Modified quantity if adjusted")
    rejection_reason: Optional[str] = None
    
    # Guardrail flags
    guardrail_flags: Dict[str, Any] = Field(default_factory=dict)
    safe_mode_active: bool = False
    
    # HITL requirements
    hitl_required: bool = False
    hitl_reason: Optional[str] = None
    hitl_status: Literal["pending", "approved", "rejected", "timeout"] = "pending"
    
    # Risk metrics at approval time
    remaining_loss_budget: float
    trades_today: int
    current_strategy: Optional[StrategyType] = None


class PaperOrder(BaseModel):
    """Paper trading order with simulated execution."""
    order_id: str = Field(..., description="Unique order ID (UUID)")
    intent_id: Optional[int] = None
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Order details
    symbol: str
    side: TradeSide
    quantity: int
    order_type: OrderType
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None
    
    # Execution details
    status: OrderStatus
    fill_price: Optional[float] = None
    fill_timestamp: Optional[datetime] = None
    slippage: Optional[float] = Field(None, description="Slippage in rupees")
    brokerage: Optional[float] = Field(None, description="Brokerage in rupees")
    
    # Paper trading metadata
    simulated_ltp: Optional[float] = None
    
    class Config:
        json_schema_extra = {
            "example": {
                "order_id": "uuid-1234",
                "symbol": "RELIANCE",
                "side": "buy",
                "quantity": 10,
                "order_type": "market",
                "status": "filled",
                "fill_price": 2451.25,
                "slippage": 1.25,
                "brokerage": 20.00
            }
        }


class Position(BaseModel):
    """Trading position (paper or live)."""
    symbol: str
    quantity: int = Field(..., description="Positive for long, negative for short")
    avg_price: float
    current_price: Optional[float] = None
    unrealized_pnl: float = 0.0
    
    # Associated orders
    entry_order_id: Optional[str] = None
    stop_loss_price: Optional[float] = None
    target_price: Optional[float] = None
    
    # Metadata
    strategy: Optional[StrategyType] = None
    opened_at: datetime = Field(default_factory=datetime.now)
    last_updated: datetime = Field(default_factory=datetime.now)
    
    def update_pnl(self, current_price: float):
        """Update unrealized PnL based on current price."""
        self.current_price = current_price
        if self.quantity > 0:  # Long position
            self.unrealized_pnl = (current_price - self.avg_price) * self.quantity
        else:  # Short position
            self.unrealized_pnl = (self.avg_price - current_price) * abs(self.quantity)
        self.last_updated = datetime.now()


class DailyState(BaseModel):
    """Daily trading state and metrics."""
    date: str = Field(..., description="Date in YYYY-MM-DD format")
    
    # PnL tracking
    realized_pnl: float = 0.0
    unrealized_pnl: float = 0.0
    total_pnl: float = 0.0
    
    # Loss budget
    loss_budget_remaining: float
    max_daily_loss: float
    
    # Trading state
    safe_mode: bool = False
    active_strategy: Optional[StrategyType] = None
    strategy_switched_at: Optional[datetime] = None
    
    # Trade counts
    trades_count: int = 0
    max_trades: int
    
    # HITL tracking
    hitl_approvals_pending: int = 0
    hitl_approvals_given: int = 0
    
    def update_pnl(self, realized: float = 0.0, unrealized: float = 0.0):
        """Update PnL and loss budget."""
        self.realized_pnl += realized
        self.unrealized_pnl = unrealized
        self.total_pnl = self.realized_pnl + self.unrealized_pnl
        
        # Update loss budget (only count losses)
        total_loss = min(0, self.total_pnl)
        self.loss_budget_remaining = self.max_daily_loss + total_loss  # total_loss is negative
        
        # Trigger SAFE_MODE if loss budget exhausted
        if self.loss_budget_remaining <= 0:
            self.safe_mode = True
    
    def can_trade(self) -> tuple[bool, Optional[str]]:
        """Check if trading is allowed."""
        if self.safe_mode:
            return False, "SAFE_MODE active - max daily loss reached"
        if self.trades_count >= self.max_trades:
            return False, f"Max trades per day ({self.max_trades}) reached"
        if self.loss_budget_remaining <= 0:
            return False, "No loss budget remaining"
        return True, None


class StrategyScore(BaseModel):
    """Individual strategy evaluation score."""
    strategy: StrategyType
    confidence: float = Field(..., ge=0, le=1)
    rationale: str
    key_metrics: Dict[str, Any] = Field(default_factory=dict)


class AgentDecision(BaseModel):
    """Generic agent decision for logging."""
    timestamp: datetime = Field(default_factory=datetime.now)
    agent_name: str
    decision_type: str
    decision_data: Dict[str, Any]
    reasoning: Optional[str] = None
